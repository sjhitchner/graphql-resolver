package resolver

{{/* template "imports" .Imports 

{{ define "ResolverMapping" }}
	{{ if .IsList }}
		resolvers := make([]*{{ .ResolverName }}, 0, len(obj)
		for _, o := range obj {
			resolvers = append(resolvers, &{{ .ResolverName }} {t.aggregator,  &o}
		}
		return resolvers
	{{ else }}
		return &{{ .ResolverName }}{t.aggregator,  obj}
	{{ end }}
{{ end }}

*/}}

// import aggregator
// import context
// import errors

type Resolver struct {
	aggregator Aggregator
}

{{ range $q := .Queries }}
func (t *Resolver) {{ $q.Name }}(ctx context.Context 
{{ if  $q.Args }}
args struct{
{{- range $a := $q.Args }}
$a.Name $a.Type
{{ end }}
}) ($q.Return, error) {
	{{ $q.Name }}, err := t.aggregator.{{ $q.Aggregator }}(ctx context.Context)
	if err != nil {
		return nil, err
	}

	{{/* template "ResolverMapping" $q */}}	
}
{{ end }}
{{ end }}

{{ range $m := .Models }}
{{ $m.Description }}
type {{ $m.Name }}Resolver struct {
{{ range $f := $m.Fields }}
	{{ if $f.Description }}// {{ $f.Description }}{{ end }}
	{{ $f.Name -}}
	{{- if $f.Args -}}(

	){{- end -}}
	{{ $f.ReturnType }}
{{ end }}
}
{{ end }}


