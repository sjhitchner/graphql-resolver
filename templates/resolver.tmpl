package resolver

{{/* template "imports" .Imports 

{{ define "ResolverMapping" }}
	{{ if .IsList }}
		resolvers := make([]*{{ .ResolverName }}, 0, len(obj)
		for _, o := range obj {
			resolvers = append(resolvers, &{{ .ResolverName }} {t.aggregator,  &o}
		}
		return resolvers
	{{ else }}
		return &{{ .ResolverName }}{t.aggregator,  obj}
	{{ end }}
{{ end }}

*/}}

// import aggregator
// import context
// import errors

{{ range $enum := .Enums }}
// {{ $enum.Description }}
type {{ $enum.Name }} int

const (
{{ range $i, $v := $enum.Values }}
	{{ $v.Description }}
	{{ $v.Name }} {{ if eq $i 0 }}{{ $enum.Name }} = iota{{ end }}
{{ end }}

{{ end }}

type Resolver struct {
	aggregator Aggregator
}

{{ define "ResolverMethod" }}
{{ if .Field.Description }}// {{ .Field.Description }}{{ end }}
func (t *{{ .ResolverName }}Resolver) {{ .Field.Name | camel }}(ctx context.Context 
  {{- if .Field.Args -}}
    args struct{
    {{- range $a := .Field.Args }}
	  {{ $a.Name }} {{ $a.Type }} 
    {{ end }}
 }{{ end -}}
) ({{ .Field.ReturnType }}, error)
{{- end -}}


{{/*

{{ range $q := .Queries }}
func (t *Resolver) {{ $q.Name }}(ctx context.Context 
{{ if  $q.Args }}
args struct{
{{- range $a := $q.Args }}
$a.Name $a.Type
{{ end }}
}) ($q.Return, error) {
	{{ $q.Name }}, err := t.aggregator.{{ $q.Aggregator }}(ctx context.Context)
	if err != nil {
		return nil, err
	}

	{{ template "ResolverMapping" $q }}	
}
{{ end }}
{{ end }}
*/}}


{{ range $m := .Models }}
{{ $m.Description }}
type {{ $m.Name }}Resolver struct {
	aggregator Aggregator
	obj *{{ $m.Name }}
}

{{- range $f := $m.Fields -}}
{{ template "ResolverMethod" args "ResolverName" $m.Name "Field" $f }} {
}
{{ end }}
{{ end }}


